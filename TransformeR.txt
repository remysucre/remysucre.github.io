-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | eDSL in R for Safe Variable Transformarion
--   
--   Arbitrary data transformations that work at the level of single
--   individual data can be safely applied before applying a differentially
--   private data analysis if an adversary only gets to observe the result
--   of the differentially private analysis. The current version of the PSI
--   prototype offers support for writing variable transformations as R
--   programs that can be run on the data before running the other private
--   statistics. Arbitrary R programs can allow for leakage of information
--   beyond the output, and "side-channel attacks" where an adversary
--   observes this additional leakage and thereby undermines the privacy
--   guarantees. TransformeR is a subset of the R language that can serve
--   as a domain specifc language useful to write the needed data
--   transformations and at the same time be more maneageable for
--   preventing security weaknesses and side-channel attacks.
@package TransformeR
@version 0.1.0.0


-- | Grammar for TransmormeR, with abstract and concrete syntax (the latter
--   defined in <tt>Show</tt> instances). This is work in progress, and the
--   final goal is to implement a subset of R grammar with (refinement)
--   type annotations. Refer to the paper/design doc on Github for the
--   definition of the grammar.
module Syntax

-- | A transformation has a name, is signed by an input- and a return-data
--   descriptor and has a body.
data Transformation
TRANS :: Name -> Sig -> Sig -> Expression -> Transformation

-- | Record-type encodes column names and their descriptors
data Sig
Sig :: [(Name, Descriptor)] -> Sig

-- | expressions that can appear in the transformation body: a literal
--   value, a field access, an operator application, a record, a variable,
--   a field mutation, sequencing of expressions, or a variable assignment.
--   The order might matter during pretty printing (operator precedence)!
data Expression

-- | literal value
LIT :: Value -> Expression

-- | field access
PROJ :: Expression -> Field -> Expression

-- | operator application
OP :: OPR -> [Expression] -> Expression

-- | record
REC :: [(Field, Expression)] -> Expression

-- | variable
VAR :: Name -> Expression

-- | field mutation
MUTATE :: Name -> Field -> Expression -> Expression

-- | sequencing of exps
SEQ :: Expression -> Expression -> Expression

-- | variable assignment
ASSIGN :: Name -> Expression -> Expression

-- | a descriptor encodes range
type Descriptor = Range

-- | range encodes information neccessary to infer the sensitivity
--   (together with the DP-mechanism)
data Range

-- | currently using closed intervals for floats
INTERVAL :: Number -> Number -> Range

-- | a set of categories (bins in a histogram)
SET :: [Name] -> Range

-- | a value is either
data Value

-- | a number (currently floats only)
NUM :: Number -> Value

-- | a category (bin name in a histogram)
CAT :: Category -> Value

-- | a record
MAP :: [(Field, Value)] -> Value

-- | supported statistical operators
data OPR

-- | sum 2 numbers
SUM :: OPR

-- | concatinate 2 categories
CONCAT :: OPR
instance Show OPR
instance Show Value
instance Show Range
instance Show Expression
instance Show Sig
instance Show Transformation


-- | Type System for TransmormeR, This is work in progress, and the final
--   goal is to implement a type system consistent with R semantics. There
--   are 2 ways to do that: implement a interpreter from the semantics
--   defined in the paper/design doc, and loop {test, change} until you
--   massage the semantics so that the interpreter behaves the same on all
--   inputs you can think of just like R does. Or, you can generate a bunch
--   of well-typed TransformeR programs and run them under R, modify
--   TransformeR until all outputs have the type that TransformeR claims
--   them to have. Refer to the paper/design doc on Github for the
--   definition of the grammar.
module Types

-- | types are refined with ranges. refinement types should implement a
--   check for well-typedness
class RefTy t
tyOK :: RefTy t => t -> Bool

-- | a record type
data RecTy
RecTy :: [(Label, Ty)] -> RecTy

-- | a primitive type
data Ty
NumTy :: (Number, Number) -> Ty
CatTy :: [Category] -> Ty

-- | type environment stores both record type and primitive types. A better
--   design would replace <tt>Either</tt> with a home-made datatype, like
--   <tt>data Ty = PT ExTy | RT RecTy </tt> and have Gamma just store
--   <tt>Ty</tt>. <a>Gamma</a> also deserves a better data structure,
--   perhaps <a>Data.Map</a>?
type Gamma = [(Name, Either RecTy Ty)]

-- | update the type environment
mapsTo :: [(t, t1)] -> t -> t1 -> [(t, t1)]

-- | declare instances of <a>Data.Ord</a> to implement sub-type

-- | valid transformations have a type
data TransTy
TransTy :: RecTy -> RecTy -> TransTy

-- | type-check a transformation
tyTrans :: Transformation -> TransTy

-- | type-check an expression
ty :: Gamma -> Expression -> (Either RecTy Ty, Gamma)

-- | operator typing rules. Serves as a basis for all statistical
--   operations.
tyJoin :: OPR -> [Either t Ty] -> Ty
instance Show Ty
instance Eq Ty
instance Show RecTy
instance Eq RecTy
instance Show TransTy
instance Eq TransTy
instance Ord Ty
instance Ord RecTy
instance Ord TransTy
instance RefTy RecTy
instance RefTy Ty


-- | Parser combinators for TransmormeR, using the <a>Text.Parsec</a>
--   library. This is work in progress, and the final goal is to implement
--   a subset of R grammar with (refinement) type annotations. Refer to the
--   paper/design doc on Github for the definition of the grammar.
module Parse

-- | run a parser on an input string. <tt>parse value "t.R" "1.23"</tt>
--   will return (hopefully!) <tt>Right (NUM 1.23)</tt>
parse :: Parser a -> SourceName -> String -> Either ParseError a

-- | parse a TransformeR program
prog :: Parser Transformation

-- | parse an expression, which can be a term or some operation over terms.
expr :: Parser Expression

-- | parse a term
term :: Parser Expression

-- | parse a value
value :: Parser Value

-- | parse an operator, consider to integrate into <a>table</a>
opr :: Parser OPR

-- | table of operators with fixities and precedence. note that field
--   access is treated as a post-fix operator
table :: OperatorTable String u Identity Expression

-- | parse a record-type signature
recsig :: Parser Sig

-- | parse a primitive type signature
tysig :: Parser Descriptor
