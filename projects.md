Yes, I'm looking for students to join my lab.
There are two ways you can demonstrate your potential to become a good researcher: 

1. You have made significant contribution to a research project, even if the project has not succeeded yet. 
2. If you don't have any research experience, complete one of the tasks below *independently*.

Independently means you will complete the task by yourself, without any help from me.
Please only contact me when you have made significant progress completing the task.
Each task is roughly equivalent one semester-long course with intense focus.

Most of my research concerns databases and programming languages, but I have a wide range of interests, and you can get me excited about anything if you try.

* Implement a [tree automata minimization algorithm](https://www.isi.edu/~jonmay/pubs/tr-633.pdf) and use it to [speed up egraph extraction](https://remy.wang/reports/dfta.pdf).

* Use [TACO](http://tensor-compiler.org) to answer queries in the [join ordering benchmark](https://github.com/gregrahn/join-order-benchmark), and try to beat the performance of [DuckDB](https://duckdb.org).

* Do the same as a bove, but use some other system with a scheduling language like [Halide](https://halide-lang.org) or [Exo](https://exo-lang.dev).

* Merge [ASP extraction](https://github.com/egraphs-good/extraction-gym/pull/1) to [egg](https://github.com/egraphs-good/egg) and make it fast. 

* Implement the [improved Yannakakis algorithm](https://webusers.imj-prg.fr/~arnaud.durand/papers/BDGlongversion.pdf) and try to beat the performance of DuckDB on join order benchmark. You may also use techniques from [factorized databases](https://www.cs.ox.ac.uk/dan.olteanu/papers/os-sigrec16.pdf).

* Understand the [PANDA algorithm](https://arxiv.org/pdf/1612.02503.pdf), implement it, and make a presentation explaining it.

* Understand the [FAQ algorithm](https://arxiv.org/abs/1504.04044), implement it, and make a presentation explaining it.

* Come up with a [dynamic programming](https://www.researchgate.net/profile/Thomas_Neumann2/publication/47861835_Analysis_of_Two_Existing_and_One_New_Dynamic_Programming_Algorithm_for_the_Generation_of_Optimal_Bushy_Join_Trees_without_Cross_Products/links/0912f506d90ad19031000000.pdf) algorithm for join order optimization for [free join](https://arxiv.org/abs/2301.10841).

* Implement [query by direct manipulation](https://people.csail.mit.edu/ebakke/research/sieuferd_sigmod2016.pdf).

* Finish the extension of Souffle to support [recursive aggregates](https://github.com/souffle-lang/souffle/pull/2263).

* Implement Datalog modulo equivalence and benchmark it against egglog.

* Implement and benchmark generalized semi-naive evaluation for Datalog.

* Experiment with different [search algorithms](https://en.wikipedia.org/wiki/Combinatorial_search) in [egg](https://egraphs-good.github.io).

* Implement an SMT solver from scratch.

* Solve Andrew Lumsdaine's challenge with [Rosette](https://emina.github.io/rosette/) (see [Cosette](https://cosette.cs.washington.edu) and [FGH](https://arxiv.org/abs/2202.10390)).

* Design a decision procedure for NRA^\*^ (see [LIA^\*^](https://www.cs.yale.edu/homes/piskac/papers/2020LevatichETALSolvingLIAstar.pdf), [NRA](https://en.wikipedia.org/wiki/Real_closed_field#Decidability_and_quantifier_elimination), and [these slides](https://ths.rwth-aachen.de/wp-content/uploads/sites/4/teaching/vorlesung_satchecking/ws14_15/09a_nonlinear_handout.pdf)), or prove it's undecidable.

* Study how data is used in any recent breakthough in science. For inspiration, checkout [quanta](https://www.quantamagazine.org/videos/2021s-biggest-breakthroughs-in-physics/). Focus on projects relevant to databases research.

* Make a screenless smartphone with voice-based UI.

* Make a "digital analog projector": instead of connecting to HDMI, you just put your laptop in front of the camera, and the system automatically applies filters to the video to make it look nice.

* Re-implement your favorite paper. To make sure you don't just download the code and run it, implement it using a different programming language. 
